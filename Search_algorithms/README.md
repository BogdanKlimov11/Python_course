<h1 id="top">Алгоритмы поиска</h1>

---

<!-- Оглавление -->
<h2>Оглавление <a href="#top">↑top↑</a></h2>

<nav>
    <ul>
        <li><a href="#определение">Определение</a></li>
        <li><a href="#оценка-сложности">Оценка сложности</a></li>
        <li><a href="#виды-сложностей">Виды сложностей</a></li>
        <li><a href="#раздел-1">Линейный поиск (Linear search)</a></li>
        <li><a href="#раздел-2">Бинарный поиск (Binary search)</a></li>
        <li><a href="#раздел-3">Интерполяционный поиск (Interpolation search)</a></li>
        <li><a href="#раздел-4">Поиск в ширину (BFS - Breadth-First search)</a></li>
        <li><a href="#раздел-5">Поиск в глубину (DFS - Depth-First search)</a></li>
        <li><a href="#раздел-6">Поиск A* (A* search)</a></li>
        <li><a href="#раздел-7">Поиск Хилла (Hill climbing search)</a></li>
        <li><a href="#раздел-8">Поиск на основе эвристического метода (Heuristic search)</a></li>
        <li><a href="#раздел-9">Поиск в хэш-таблице (Hash table search)</a></li>
        <li><a href="#раздел-10">Поиск в дереве (Tree search)</a></li>
        <li><a href="#раздел-11">Поиск в суффиксном дереве (Suffix tree search)</a></li>
        <li><a href="#раздел-12">Поиск Кнута-Морриса-Пратт (Knuth-Morris-Pratt [KMP] search)</a></li>
        <li><a href="#раздел-13">Поиск Бойера-Мура (Boyer-Moore search)</a></li>
        <li><a href="#раздел-14">Поиск Рабина-Карпа (Rabin-Karp search)</a></li>
        <li><a href="#раздел-15">Поиск Вагнера-Фишера (Wagner-Fischer search)</a></li>
        <li><a href="#раздел-16">Поиск Форда-Фалкерсона (Ford-Fulkerson search)</a></li>
        <li><a href="#раздел-17">Поиск Эдмондса-Карпа (Edmonds-Karp search)</a></li>
        <li><a href="#раздел-18">Поиск в играх с нулевой суммой [минимакс] (Minimax search)</a></li>
        <li><a href="#раздел-19">Поиск в кэше (Cache search)</a></li>
        <li><a href="#раздел-20">Поиск в глобальной оптимизации (Global optimization search)</a></li>
    </ul>
</nav>

---

<h2 id="определение">Определение <a href="#top">↑top↑</a></h2>

**Алгоритм поиска** - это специальная процедура или набор инструкций, разработанный для нахождения определенного элемента 
или решения задачи в наборе данных или пространстве состояний. Целью алгоритма поиска является обнаружение и извлечение 
информации из множества данных, подходящих под заданные условия, в наиболее эффективный и оптимальный способ.

В основном алгоритмы поиска могут выполнять поиск в различных контекстах, таких как массивы, списки, графы, деревья, базы 
данных и многое другое. Они могут быть использованы для нахождения определенного элемента, поиска максимального или 
минимального значения, поиска пути или решения других задач, в зависимости от конкретной ситуации.

Ключевые аспекты алгоритмов поиска включают в себя правильность (то есть способность точно найти нужный элемент или решение), 
эффективность (снижение затрат по времени и ресурсам) и универсальность (применимость к различным типам данных и задачам).

Таким образом, алгоритмы поиска играют важную роль в области информатики и программирования, обеспечивая возможность 
эффективного обработки и анализа данных.

---

<h2 id="оценка-сложности">Оценка сложности <a href="#top">↑top↑</a></h2>

Определение сложности алгоритма включает в себя анализ количества ресурсов (таких как время и память), которые 
требуются для выполнения алгоритма в зависимости от размера входных данных. Вот основные способы определения 
сложности алгоритма:

1. **Временная сложность:** Это оценка количества операций, которые выполняет алгоритм в зависимости от размера
входных данных. Временная сложность может быть выражена в терминах лучшего, худшего или среднего случая.
Обычно она измеряется в "большом О" нотации, где n - размер входных данных. Оценка временной сложности позволяет
понять, как быстро алгоритм будет работать с увеличением размера входных данных.

2. **Пространственная сложность:** Это оценка количества памяти, которое требуется для выполнения алгоритма в
зависимости от размера входных данных. Пространственная сложность также может быть выражена в "большом О"
нотации, где n - размер входных данных. Оценка пространственной сложности позволяет понять, сколько памяти
будет использовано алгоритмом при обработке данных.

4. **Лучший, худший и средний случаи:** Некоторые алгоритмы могут иметь различную сложность в разных случаях.
Лучший случай представляет собой наилучший сценарий выполнения алгоритма, худший случай - наихудший сценарий,
а средний случай - средний сценарий, обычно применяется к случайно распределенным данным.

5. **Асимптотический анализ:** Это метод анализа сложности, который сосредотачивается на поведении алгоритма
при стремлении размера входных данных к бесконечности. В основе асимптотического анализа лежит "большая О"
нотация, которая определяет верхнюю границу роста времени выполнения или потребления памяти алгоритма.

Определение сложности алгоритма помогает выбирать наиболее подходящий алгоритм для конкретной задачи и предсказывать 
его поведение при работе с различными размерами входных данных.

---

<h2 id="виды-сложностей">Виды сложностей <a href="#top">↑top↑</a></h2>

<table>
    <tr>
        <th>Обозначение</th>
        <th>Название</th>
    </tr>
    <tr>
        <td>$O(1)$</td>
        <td>Константная сложность</td>
    </tr>
    <tr>
        <td>$O(\log n)$</td>
        <td>Логарифмическая сложность</td>
    </tr>
    <tr>
        <td>$O(n)$</td>
        <td>Линейная сложность</td>
    </tr>
    <tr>
        <td>$O(n \log n)$</td>
        <td>Квази-линейная сложность (линейно-логарифмическая)</td>
    </tr>
    <tr>
        <td>$O(n^a), a \in \mathbb N, a \geq 2$</td>
        <td>Степенная сложность</td>
    </tr>
    <tr>
        <td>$O(a^n), a \in \mathbb N, a \geq 2$</td>
        <td>Показательная сложность (экспоненциальная)</td>
    </tr>
    <tr>
        <td>$O(n!)$</td>
        <td>Факториальная сложность</td>
    </tr>
</table>

<img src="https://github.com/BogdanKlimov11/Python_course/assets/136115919/f9145fe6-f24d-47d6-894a-d185c46ac234" alt="Algorithm complexity" width="60%" height="auto">

---

<!-- Разделы -->
<h2 id="раздел-1">Линейный поиск (Linear search) <a href="#top">↑top↑</a></h2>

Линейный поиск является простым методом поиска элемента в массиве путем последовательного просмотра каждого элемента до 
тех пор, пока не будет найден искомый элемент или не будет достигнут конец массива.

<h3>Описание шагов алгоритма:</h3>

1. Начинаем с начала массива.

2. Последовательно проверяем каждый элемент массива.

3. Если текущий элемент равен целевому значению, то возвращаем индекс этого элемента.

4. Если мы досмотрели до конца массива и не нашли искомый элемент, возвращаем -1 или другое значение, указывающее на 
  отсутствие элемента.

<h3>Временная сложность:</h3>

- **Худшая сложность:** $O(n)$ - в худшем случае, когда искомый элемент отсутствует в массиве или находится в самом конце,
  придется просмотреть все элементы массива.

- **Средняя сложность:** $O(n)$ - если искомый элемент встречается среди элементов массива с равной вероятностью.

- **Лучшая сложность:** $O(1)$ - когда искомый элемент находится в начале массива или является первым элементом. Однако это 
  крайне редкий случай и, в общем, не характерен для линейного поиска.

Линейный поиск прост в реализации и может быть полезен для небольших наборов данных или когда не требуется предварительная 
сортировка массива. Однако на больших массивах более эффективными могут оказаться другие алгоритмы поиска, такие как 
бинарный поиск, если данные упорядочены.

---

<h2 id="раздел-2">Бинарный поиск (Binary search) <a href="#top">↑top↑</a></h2>

Бинарный поиск является эффективным методом поиска элемента в упорядоченном массиве путем многократного деления области 
поиска пополам и последующего сравнения среднего элемента с целевым значением.

<h3>Описание шагов алгоритма:</h3>

1. Начинаем сортированный массив.

2. Устанавливаем начальный индекс как 0 и конечный индекс как последний элемент массива.

3. Вычисляем индекс среднего элемента как (начальный индекс + конечный индекс) / 2.

4. Сравниваем целевое значение с элементом в средине массива.

5. Если целевое значение равно среднему элементу, возвращаем его индекс.

6. Если целевое значение меньше среднего элемента, обновляем конечный индекс на (средний индекс - 1) и повторяем шаги с
   3 по 5.

7. Если целевое значение больше среднего элемента, обновляем начальный индекс на (средний индекс + 1) и повторяем шаги с
   3 по 5.

8. Повторяем шаги 3-7 до тех пор, пока не найдем целевой элемент или не достигнем окончания поиска (когда начальный индекс
    становится больше конечного).

<h3>Временная сложность:</h3>

- **Худшая сложность:** $O(log n)$ - где 'n' - в худшем случае, когда искомый элемент отсутствует в массиве или находится в
  самом конце или начале, количество итераций будет логарифмически зависеть от размера массива.

- **Средняя сложность:** $O(log n)$ - аналогично худшему случаю, при условии, что элементы равновероятно могут находиться в
  любой части массива.

- **Лучшая сложность:** $O(1)$ - когда искомый элемент находится в самом центре массива. Однако такой случай крайне редок и
  в общем не характерен для бинарного поиска.

Бинарный поиск является одним из наиболее эффективных алгоритмов поиска, особенно на упорядоченных массивах. Он имеет 
значительно более низкую сложность по сравнению с линейным поиском для больших массивов данных.

---

<h2 id="раздел-3">Интерполяционный поиск (Interpolation search) <a href="#top">↑top↑</a></h2>
    <p>. . .</p>

---

<h2 id="раздел-4">Поиск в ширину (BFS - Breadth-First search) <a href="#top">↑top↑</a></h2>
    <p>. . .</p>

---

<h2 id="раздел-5">Поиск в глубину (DFS - Depth-First search) <a href="#top">↑top↑</a></h2>
    <p>. . .</p>

---

<h2 id="раздел-6">Поиск A* (A* search) <a href="#top">↑top↑</a></h2>
    <p>. . .</p>

---

<h2 id="раздел-7">Поиск Хилла (Hill climbing search) <a href="#top">↑top↑</a></h2>
    <p>. . .</p>

---

<h2 id="раздел-8">Поиск на основе эвристического метода (Heuristic search) <a href="#top">↑top↑</a></h2>
    <p>. . .</p>

---

<h2 id="раздел-9">Поиск в хэш-таблице (Hash table search) <a href="#top">↑top↑</a></h2>
    <p>. . .</p>

---

<h2 id="раздел-10">Поиск в дереве (Tree search) <a href="#top">↑top↑</a></h2>
    <p>. . .</p>

---

<h2 id="раздел-11">Поиск в суффиксном дереве (Suffix tree search) <a href="#top">↑top↑</a></h2>
    <p>. . .</p>

---

<h2 id="раздел-12">Поиск Кнута-Морриса-Пратт (Knuth-Morris-Pratt [KMP] search) <a href="#top">↑top↑</a></h2>
    <p>. . .</p>

---

<h2 id="раздел-13">Поиск Бойера-Мура (Boyer-Moore search) <a href="#top">↑top↑</a></h2>
    <p>. . .</p>

---

<h2 id="раздел-14">Поиск Рабина-Карпа (Rabin-Karp search) <a href="#top">↑top↑</a></h2>
    <p>. . .</p>

---

<h2 id="раздел-15">Поиск Вагнера-Фишера (Wagner-Fischer search) <a href="#top">↑top↑</a></h2>
    <p>. . .</p>

---

<h2 id="раздел-16">Поиск Форда-Фалкерсона (Ford-Fulkerson search) <a href="#top">↑top↑</a></h2>
    <p>. . .</p>

---

<h2 id="раздел-17">Поиск Эдмондса-Карпа (Edmonds-Karp search) <a href="#top">↑top↑</a></h2>
    <p>. . .</p>

---

<h2 id="раздел-18">Поиск в играх с нулевой суммой [минимакс] (Minimax search) <a href="#top">↑top↑</a></h2>
    <p>. . .</p>

---

<h2 id="раздел-19">Поиск в кэше (Cache search) <a href="#top">↑top↑</a></h2>
    <p>. . .</p>

---

<h2 id="раздел-20">Поиск в глобальной оптимизации (Global optimization search) <a href="#top">↑top↑</a></h2>
    <p>. . .</p>

---
